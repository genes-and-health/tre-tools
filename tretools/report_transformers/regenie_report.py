"""
This contains the RegineReportTransformer class. This class is used to transform a list of PhenotypeReports
into a data that can be used by Regenie.

A regenie report is a wide file that has the following
columns:
- NHS Numbers
- FID (Family ID) - which is equal to 1 as we are not using family data
- IID (Individual ID) - which is either GSA or Broad ID
- Phenotype binary columns - one for each phenotype of ICD10 code from A01 to Q99 with X values included
in those counts (for example, A01X is included in A01)

The readme file should contain logs and the counts of cases per phenotype for both the GSA and Broad IDs.
"""
from __future__ import annotations
import polars as pl
from datetime import datetime
from typing import List, Dict
import os

from tretools.phenotype_report.report import PhenotypeReport
from tretools.report_transformers.base import ReportTransformer
from tretools.report_transformers.utils import logs_to_markdown_table, codelist_to_markdown_table


class RegenieReportTransformer(ReportTransformer):
    def __init__(self) -> None:
        super().__init__()
        self.data = None
        self.log = []
        self.summary = []


    @classmethod
    def load_from_objects(cls, objects: List[PhenotypeReport]) -> RegenieReportTransformer:
        """
        Loads a list of PhenotypeReports into a RegenieReportTransformer. Each PhenotypeReport
        will be in a list under the attribute reports.

        Args:
            objects (List[PhenotypeReport]): A list of PhenotypeReports.

        Returns:
            ReportTransformer: A RegenieReportTransformer with the PhenotypeReports loaded into it.
        """
        transformer = RegenieReportTransformer()
        transformer.reports = objects
        transformer.log.append(f"{datetime.now()}: Loaded {len(objects)} PhenotypeReports into the RegenieReportTransformer.")
        return transformer

    def load_mapping_file(self, mapping_path: str, config: Dict[str, str]) -> None:
        """
        Loads the reference files into the RegenieReportTransformer.

        Args:
            broad_id_path (str): The path to the Broad ID reference file.
            gsa_path (str): The path to the GSA reference file.

        Raises:
            ValueError: If the reference files do not exist or are empty.
        """
        if not self._check_path(mapping_path):
            raise ValueError(f"The Broad ID/GSA reference file {mapping_path} does not exist or is empty.")

        self.log.append(f"{datetime.now()}: Loading the Broad ID/GSA reference file from {mapping_path}.")

        data = pl.read_csv(mapping_path)
        data = data.rename(config)
        self.data = data

    def _check_path(self, path) -> bool:
        """
        Checks that the reference files exist and are not empty.

        Returns:
            bool: True if the files exist and are not empty, False otherwise.
        """
        if not os.path.exists(path):
            return False
        if os.path.getsize(path) == 0:
            return False
        return True


    def _write_readme(self, path: str) -> None:
        """
        Writes the readme file to the path. This file contains the logs and the counts of cases per phenotype.

        Args:
            path:

        Returns:

        """
        markdown = f"# Regenie Report\n\n## Logs\n\n"

        # Add datetime as String in format DD Month YYYY
        markdown += "## Report Generation Date and Time\n\n"
        markdown += f"This report was generated on {datetime.now().strftime('%d %B %Y')}.\n\n"

        # Explain what the report is
        markdown += "## Report Overview\n\n"
        markdown += "This report contains the counts of cases per phenotype for both the GSA and " \
                     "Broad IDs. It has been automatically generated by the 'tre-tools' package, " \
                     "available at [TRE Tools on GitHub](https://github.com/genes-and-health/tre-tools)." \
                     "For detailed information about this tool, please refer to the [README.md](https://github.com/genes-and-health/tre-tools/blob/main/README.md) " \
                     "in the 'tre-tools' GitHub repository. Your feedback on this tool is highly appreciated.\n\n" \
                     "This tool aggregates datasets from various sources and utilises specific codelists to identify events in the dataset. " \
                     " The focys of this report is to provide a wide file that can be used by Regenie where the columns are the phenotypes and the rows are the NHS numbers. \n\n"

        # Regenie Report
        ## Logs
        markdown += "### Logs for Generating the Regenie Report\n\n"
        markdown += "In the interest of transparency, the logs for generating this report are provided below.\n\n"

        markdown += logs_to_markdown_table(self.log)
        markdown += "\n\n"
        with open(f"{path}/README.md", "w") as file:
            file.write(markdown)

    def _write_summary(self, summary_counts: List[Dict[str, int]], path: str) -> None:
        """
        Writes the summary file to the path. This file contains the counts of cases per phenotype.

        Args:
            summary_counts: A list of dictionaries containing the counts of cases per phenotype.
            path: The path to write the summary file to.

        Returns:
            None
        """
        summary = pl.DataFrame(summary_counts)
        summary = summary.sort("phenotype")
        self.log.append(f"{datetime.now()}: Writing the summary file to {path}/summary.csv.")

        # If the path does not exist, create it
        if not os.path.exists(path):
            os.makedirs(path)
        summary.write_csv(f"{path}/summary.csv")

    def _combine_reports(self) -> Dict:
        # empty dict to hold regenies reports
        final_report = {}
        self.log.append(f"{datetime.now()}: Combining the PhenotypeReports into a Regenie report.")

        # loop through each report
        for phenotype in self.reports:
            results = pl.DataFrame()
            for i, j in phenotype.counts.items():

                # append the counts to the results DataFrame
                nhs_numbers = j['nhs_numbers'].select(pl.col("nhs_number"))
                results = results.vstack(nhs_numbers)
                self.log.append(f"{datetime.now()}: Added {len(nhs_numbers)} NHS numbers for {i} to the Regenie report.")

            # Remove duplicates
            results = results.unique()
            final_report[phenotype.name] = results

        self.log.append(f"{datetime.now()}: Finished combining the PhenotypeReports into a Regenie report.")

        return final_report


    def transform(self, path: str = "regenie_reports", with_nhs_numbers: bool = True) -> Dict:
        """
        This will transform the PhenotypeReports into a Regenie report.

        Returns:
            None
        """
        phenotypes = self._combine_reports()
        final_report = self.data
        summary_counts = []

        # loop through each phenotype and if nhs number in the phenotype, then add a 1 to a new column
        # if not, add a 0. The final report will be a wide file.
        for phenotype, nhs_numbers in phenotypes.items():
            # make a new column with 1s
            nhs_numbers = nhs_numbers.with_columns(
                phenotype = pl.lit(1)
            )
            # rename the phenotype column to the phenotype name
            nhs_numbers = nhs_numbers.rename({"phenotype": phenotype})
            # merge the nhs numbers with the mapping file
            final_report = final_report.join(nhs_numbers, on="nhs_number", how="left")
            # Write the summary counts
            summary_counts.append({"phenotype": phenotype, "counts": len(nhs_numbers)})

        # fill the NaNs with 0s
        final_report = final_report.fill_null(0)

        # Add FID column with 1 for all rows
        final_report = final_report.with_columns(
            FID = pl.lit(1)
        )

        # Reorder the columns to FID, broad_id, gsa_id, phenotype columns
        columns = final_report.columns
        columns.remove("FID")
        columns.remove("broad_id")
        columns.remove("gsa_id")
        columns.remove("nhs_number")

        # conditional logic to drop the nhs_number column if with_nhs_numbers is False
        columns_to_keep = ["FID", "broad_id", "gsa_id"]
        if with_nhs_numbers:
            columns_to_keep.append("nhs_number")
        columns = columns_to_keep + columns
        final_report = final_report.select(columns)

        # Write the summary file
        self._write_summary(summary_counts, path)

        # Write the readme file
        self._write_readme(path)

        # make the final report
        return final_report



